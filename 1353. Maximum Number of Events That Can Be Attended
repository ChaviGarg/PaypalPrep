My solution kind of bruteforce (Ignore) (Time limit exceeded)

class Solution {

    public int maxEvents(int[][] events) {
        int maxEvents = 0;
        Set<Integer> occupiedSet = new HashSet<>();

        Arrays.sort(events, (a,b) -> a[1]-b[1]);
        for(int[] event : events){
            boolean eventAttended = false;
            for(int day=event[0]; day <= event[1] ; day++){
                if(! occupiedSet.contains(day)){
                    maxEvents++;
                    occupiedSet.add(day);
                    eventAttended = true;
                }
                if(eventAttended)
                   break;
            }    
        }
        return maxEvents;
    }
    
}

*****************************************   Optimized Solution *********************************

Referred Leetcode editorial

Approach: Greedy
Intuition
According to the problem statement, meeting i starts on startDay 
i
​
  and ends on endDay 
i
​
 . You are allowed to attend a meeting on any day within the interval [startDay 
i
​
 ,endDay 
i
​
 ]. Since only one meeting can be attended per day, we apply a greedy strategy: if it's possible to attend both meetings i and j on day k, we should prioritize the one with the earlier end time, i.e., min(endDay 
i
​
 ,endDay 
j
​
 ). This ensures we leave more room to accommodate other meetings later.

Following this principle, we assume that the latest any meeting ends is maxDay. We can then iterate through each day from 1 to maxDay and greedily choose which meeting to attend on each day. To do this efficiently, we use a min-heap to keep track of the end times of currently available meetings. We also sort all meetings by their start time in advance.

Let the current day be i. At each day, we perform the following steps:

Add to the candidate queue (the min-heap) all meetings whose start day is less than or equal to i. At this point, the heap contains all meetings available to attend on day i or earlier.

Remove from the heap all meetings whose end day is less than i, as they can no longer be attended.

If the heap is not empty, we attend the meeting with the earliest end time (which is at the top of the heap), increment the count of attended meetings by 1, and remove it from the heap.

Finally, return the total number of meetings attended.

********************************************************************************************************************************

class Solution {
   
    public int maxEvents(int[][] events) {
        
        int maxDays = 0, index=0, ans = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        for(int[] event : events){
            maxDays = Math.max(maxDays, event[1]);
        }

        Arrays.sort(events, (a,b) -> a[0]-b[0]);


        for(int i=1; i <= maxDays; i++){
            while(index < events.length && events[index][0] <= i){
                pq.offer(events[index][1]);
                index++;
            }
            while(! pq.isEmpty() && pq.peek() < i){
                pq.poll();
            }
            if(! pq.isEmpty()){
                pq.poll();
                ans++;
            }
        }
        return ans;
    }
}

Complexity analysis
Let n be the number of meetings in the given array events, and let T be the maximum value of any end time in events.

Time complexity: O((T+n)logn).

Sorting the array events takes O(nlogn) time. After sorting, we iterate over each day from 1 to T, giving us T time points to process. 
For each day, we may add or remove meetings from the priority queue, which maintains at most n elements. Each insertion or deletion operation in the heap takes O(logn) time.
Therefore, the total cost of heap operations across all days is O(Tlogn). Combining both steps, the overall time complexity becomes O((T+n)logn).

Space complexity: O(n).

We use a priority queue (min-heap) to store the end times of meetings that are available to attend. Since there are at most n meetings,
the heap will contain at most n elements at any given time. Thus, the space complexity is O(n).

